[
["index.html", "R Eğitim Bilgilendirme Yardım", " R Eğitim Melike Dönertaş 22-03-2021 Bilgilendirme 22 Mart 2021 tarihinde Bioinforange tarafından düzenlenen Bioinfoconference kapsamında verilen R Eğitim çalıştay materyalini içerir. Çalıştay materyali Melike Dönertaş tarafından hazırlanmıştır, öneri ve düzeltmeler için konu başlığında “[Bioinforange R Eğitim]” kullanarak email ile ulaşabilirsiniz (lütfen sadece öneri ve düzeltmeler için arkadaşlar, çalıştay boyutunu göz önünde bulundurursanız hatalarınıza email ile yardımcı olmam imkansız. Yardım için aşağıdaki başlığa bakabilirsiniz). Yardım R konusunda karşılaştığınız sorular için öncelikle aldığınız hata ve uyarıları incelemenizi, ? operatörünü veya help() komutunu kullanarak fonksiyon, veriseti ve obje yardım sayfalarına bakmanızı, R sıkça sorulan sorular kitapçıklarına sorularınızın dahil olup olmadığını kontrol etmenizi (Genel SSS, Windows’a özgü SSS, Mac OS’a özgü SSS), bir paket kullanıyorsanız ve sorunuz bununla ilgiliyse paket yardım ve kullanım örnekleri dosyalarını incelemenizi, ve eğer bu aşamalardan sonra hala cevap bulamadıysanız sorunuzu “Nasıl güzel soru sorulur?” yönergesine göz attıktan sonra Stack Overflow R bölümüne sormanızı tavsiye ederim. Alternatif olarak, kodlama konusunda yardımlaşma platformlarına (RSG Türkiye’nin Slack kanalı gibi1) sorularınızı gönderebilirsiniz. bu şekilde başka platformlar biliyorsanız lütfen bildirin, güncelleyebilirim↩︎ "],
["çalıştay-içeriği.html", "Bölüm 1 Çalıştay içeriği", " Bölüm 1 Çalıştay içeriği R’a giriş niteliğinde birkaç ders içeriği zaten mevcut. Bu çalıştayda, süremizin sadece 2 saat olduğunu ve interaktifliğin kısıtlı olduğunu göz önüne alarak, bir R eğitiminden ziyade R’ın biyolojide uygulamalarına yönelik kısa bir örnekleme hedefledim. Çalıştay R’daki temel işlemler, operatörler, fonksiyonlar ve görselleştirme araçlarının kullanımına örnekler içerecek. Bunun için bir transkriptom veriseti kullanacağız. Bu veriseti halka açık veritabanı olan GEO’dan indirilecek. Ancak bu çalıştay “transkriptom veri analizi nasıl yapılır?”ı öğretmeyi amaçlamamaktadır. Transkriptom veri analizinde batch etkileri, normalizasyon gereklilikleri vs. bir çok kaygı vardır ve buna göre analiz basamakları gerektirmektedir. Burada yapacağımız örnek çok basit olup, gerekli olabilecek bazı basamakları atlamaktadır, bu sebeple transkriptom veri analizi örneği olarak değil R uygulamasına örnek olarak düşünülmelidir. "],
["giriş.html", "Bölüm 2 Giriş 2.1 R Kurulumu 2.2 RStudio 2.3 Başlangıç", " Bölüm 2 Giriş 2.1 R Kurulumu R’ı kullandığınız işletim sistemine göre CRAN anasayfasından indirebilirsiniz. Özellikle başlangıç seviyesinde base indirmek yeterli olacaktır. Kaynak kodu R bazlı değil de C/C++/Fortran gibi dillerde yazılmış olan paketleri kurmak için Rtools indirmeniz gerekebilir ama şimdilik base indirerek devam edebiliriz. 2.2 RStudio RStudio, R için bir IDE yani “entegre geliştirme ortamı”dır ve ücretsiz olarak RStudio websayfasından indirilebilir. Entegre geliştirme ortamları kod yazma, sonuçları ve çizdiğiniz grafikleri vs. görüntüleme, otomasyon, hata ayıklama (debugging) gibi programlama ve yazılım geliştirme bileşenlerini içinde bulunduran araçlardır. RStudio ise bunların ötesinde başka programlama dilleriyle beraber kodlama, raporlama, versiyon kontrolü, komut istemcisi ve zamanlı iş çalıştırma ve daha bir çok özellik ile birlikte geliyor. R kodlama için kesinlikle RStudio ile çalışılmasını öneriyorum. 2.3 Başlangıç Hem R hem Rstudio’yu yükleyip, RStudio açtığımızda karşımıza 3 ekran çıkar. Bunlar haricinde sol üst köşedeki “yeni” tuşuna basıp R Scriptini seçersek 4. ekran açılır. Hızlıca bunların içeriğine bakalım: Files: İçinde bulunduğumuz klasörün içindeki dosyaları listeliyor. Console: Burası kodu yazıp sonuçları gördüğümüz kısım. Denemek için 2+2 yazıp enter’a basalım. Terminal: Burası da bilgisayarınızın terminali veya komut istemcisine erişim sağlayan bir kısım. Environment: Oluşturduğumuz değişkenlerin listesini ve bilgilerini burada görebiliriz. Plots: Çizdiğimiz grafikleri görüntüleyebileceğimiz kısım. Help: Bu sekme RStudio’daki en büyük dostumuz. Açıp öğrenme linklerini kurcalamak iyi bir başlangıç. Ayrıca ? operatörü ile burada fonksiyonların yardım sayfalarını görüntüleyebiliriz. History: Mevcut R oturumunuzda yazdığınız kodları listeleyen bir kısım. Buradan önceden çalıştırdığınız kodları görebilirsiniz. Ancak daha pratik, daha çok kullanılan bir kısa yol, konsolda iken klavyedeki yukarı ok tuşu ile önceki kodları tekrar çağırmak. Geçmiş sadece açık oturumdaki kodları kaydediyor olsa da, .Rhistory dosyası sayesinde ortamlar arası geçmiş bilgisini aktarabilirsiniz. Yine de buna bağlı kalmak yerine daha sonra tekrar kullanacağımız kodları .R scripti olarak kaydetmek çok daha elverişli olacaktır. Packages: R’da yüklü olan çeşitli paketleri (kütüphaneleri) görüyoruz. Ancak buradan R ortamımıza yükleme yapmaktansa library() komutunu kullanmalıyız ki yazdığımız kodlar daha sonra hem biz hem başkaları tarafından kolaylıkla çalıştırılabilsin. Bunlardan yeni açtığımız ekran da script (betik) editör ekranı, yani kodu yazıp kaydedeceğimiz kod editörümüz. Kodu konsola yazıp çalıştabiliriz ama önerim hep editörde çalışıp çalışan kodları kaydetmeniz. Editörde yazdığımız kodu kopyala yapıştır yapmadan çalıştırmanın kolay bir yolu var: Windows’ta Ctrl + Enter, Mac’te Cmd + Enter. "],
["temel-bilgiler.html", "Bölüm 3 Temel Bilgiler 3.1 RStudio projesi 3.2 Hesap makinesi olarak R 3.3 Fonksiyonlar 3.4 Değişkenlerle çalışmak 3.5 R’da objeler 3.6 Paketler", " Bölüm 3 Temel Bilgiler Kodlari editorde yazip Ctrl+Enter ile calistirabilirsiniz. Alternatif olarak Konsol’da da kodlari yazabilirsiniz ancak editore yazdiklarinizi kaydederek yazdiklarinizdan elinizde bulunmasini istediklerinizi kaydedebilirsiniz. Onerim hep konsolu kullanmaniz, kullanisli olan kodlari tutup digerlerini / calismayanlari silip temiz bir sekilde dosyanizi kaydetmeniz. Ilk olarak hangi klasorde nerde calisiyoruz buna bakalim. Bu R’da dosya acarken ve yaptiklarimizi kaydederken onemli bir detay. Bunun icin getwd() yani ‘get directory’ komutunu kullanacagiz. Bunu calistirdigimizda aldigimiz sonuc hepimizde farkli olacaktir. Bu bilgisayarinizda nerede calistiginizi gosteriyor: getwd() ## [1] &quot;/Users/melike/GDrive/githubbooks/20210322_REgitim&quot; Bu varsayilan ortamda degil de belli bir klasorun icinde calismak istiyorsaniz, istediginiz klasore setwd() fonksiyonu ile asagidaki sekilde gecebiliriz. Ancak onerim az sonra aciklayacagim sekilde RStudio projesi kullanmaniz. setwd(&quot;~/GDrive/projects/R_Egitim&quot;) 3.1 RStudio projesi R’da calisirken her zaman proje olusturmanizi tavsiye ederim. Bu sayede hem her projenize ait kod tarihi ayrica saklanir, hem de calistiginiz klasor vs. gibi konularda endiselenmeniz gerekmez. RStudio projelerinin bunlar haricinde versiyon kontrol konusu vs. gibi ileri asamalarda kullanacaginiz diger konularda da fayda saglar. Sag ust kosedeki New Project’e basip, ’yeni klasor’u secerek yeni proje olusturabilirsiniz. Bunu yaptiktan sonra getwd() fonksiyonunu tekrar calistiralim: getwd() ## [1] &quot;/Users/melike/GDrive/githubbooks/20210322_REgitim&quot; Benim sonucumda degisen bir sey yok cunku zaten proje icinde calisiyordum ancak sizin sonucunuz degismis olmali. 3.2 Hesap makinesi olarak R 2+2 ## [1] 4 5*7 ## [1] 35 20-4 ## [1] 16 3^2 ## [1] 9 100/2 ## [1] 50 9%%5 ## [1] 4 9%/%5 ## [1] 1 3.3 Fonksiyonlar R kendi yazacaginiz fonksiyonlarin yaninda kendi icinde cok sayida fonksiyon barindirir, az once kullandigimiz getwd() fonksiyonu gibi. Bunlar fonksiyon adini takiben, parantez icinde belli argumanlar alirlar. Birkac ornek: log10(x = 100) ## [1] 2 log10(100) ## [1] 2 sqrt(16) ## [1] 4 3.3.1 Yardım almak R’da cogu fonksiyon yardim sayfasi icerir ve bunlara ? operatoru ile ulasilir: ?log10 ?getwd 3.4 Değişkenlerle çalışmak Degiskenler veri tutuculardir. Degisken atamak icin &lt;- ya da = operatorleri kullanilir. Tarihsel olarak &lt;- kullanilsa da bugun pratik nedenlerle = daha yaygindir ve kullanimi yanlis degildir. a &lt;- 3 print(a) ## [1] 3 b = 5 print(b) ## [1] 5 c = a + b print(c) ## [1] 8 c ## [1] 8 Rda degisken isimleriyle ilgili kimi kisitlamalar var: - harf ya da nokta ile baslar - ozel anlami olan kelimeler kullanilmaz (if ya da for gibi). bunlari ?reserved yazarak ogrenebilirsiniz. - yasak olmasa da Rda yer alan fonksiyon isimleri ile ayni degiskenler yaratmamaya calismak gerekir, soruna yol acabilir. - degiskenler kucuk buyuk harfe duyarlidir, a ve A birbirinden farkli degiskenlerdir. - simdiye kadar ornekleri a b x gibi harflerden olusturmus olsak da, tuttugu veriyle ilgili bir isim secmek iyi bir aliskanliktir. 3.5 R’da objeler 3.5.1 Obje türleri 5 temel obje turu var; karakter, numerik, tam sayi (integer), kompleks, mantiksal (logical/boolean). 3.5.1.1 Karakter x = &#39;a&#39; x ## [1] &quot;a&quot; class(x) ## [1] &quot;character&quot; Karakter objeleri tek karakter icermek zorunda degildir y = &quot;bu da karakter&quot; y ## [1] &quot;bu da karakter&quot; class(y) ## [1] &quot;character&quot; Degiskenler a gibi tirnak isareti olmadan yazilir, karakterler ise \"a\" ya da 'a' seklinde yazilir. R’da ’ ile \" kullanimi karakterlerde farketmez. Ayrica tirnak icindeki karakter sadece harf olmak zorunda degil, ne olursa olsun bir karakter objesidir: a = &#39;5&#39; a ## [1] &quot;5&quot; class(a) ## [1] &quot;character&quot; 3.5.1.2 Nümerik ve tam sayılar x = 3 x ## [1] 3 class(x) ## [1] &quot;numeric&quot; x = 3.14 x ## [1] 3.14 class(x) ## [1] &quot;numeric&quot; x = 1/0 x ## [1] Inf class(x) ## [1] &quot;numeric&quot; x = 0/0 x ## [1] NaN class(x) ## [1] &quot;numeric&quot; Özellikle tam sayı oluşturmak istiyorsak sonda L ekini kullanmalıyız. x = 3L x ## [1] 3 class(x) ## [1] &quot;integer&quot; 3.5.1.3 Kompleks x = 5+2i x ## [1] 5+2i class(x) ## [1] &quot;complex&quot; 3.5.1.4 Mantıksal (Logical, boolean) x = TRUE x ## [1] TRUE class(x) ## [1] &quot;logical&quot; y = T y ## [1] TRUE class(y) ## [1] &quot;logical&quot; z = FALSE z ## [1] FALSE class(z) ## [1] &quot;logical&quot; a = F a ## [1] FALSE class(a) ## [1] &quot;logical&quot; a = &#39;F&#39; a ## [1] &quot;F&quot; class(a) ## [1] &quot;character&quot; Bunlar temel obje turleri olsa da, ileride class fonksiyonunu kullandiginizda baska sonuclar alabilirsiniz. Bu temelde R’in nesne tabali dogasindan kaynakli. Ayrica objeniz bir matris ise, numerik degerlere mi karakterlere mi sahip, bunu ogrenmek icin mode() fonksiyonunu kullanmaniz gerekecek. 3.5.2 Vektör Ayni temel obje turunden olusan elementler iceren dizilerdir: x = c(1, 2, 3) x ## [1] 1 2 3 class(x) ## [1] &quot;numeric&quot; burada c vektor olusturmak icin kullanilmis bir fonksiyondur, combine ya da concatanate kelimelerinin kisaltilmisi olarak dusunulebilir. x = c(T, F, T, T) x ## [1] TRUE FALSE TRUE TRUE class(x) ## [1] &quot;logical&quot; x = c(&#39;a&#39;, &#39;b&#39;, &#39;cc&#39;) x ## [1] &quot;a&quot; &quot;b&quot; &quot;cc&quot; class(x) ## [1] &quot;character&quot; Ayni tipte olmayan degerleri birlestirirseniz, beklenmeyen davranislarla karsilasabilirsiniz. x = c(3.14, &#39;karakter&#39;, 3i+2, TRUE, F, 5L) x ## [1] &quot;3.14&quot; &quot;karakter&quot; &quot;2+3i&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;5&quot; class(x) ## [1] &quot;character&quot; Hata almadik ama objeler birlestirme sirasinda kendi modlarini koruyamadilar. Bu sebeple eger numerik vektoru karakter vektoruyle birlestirirseniz, numerik degerler karaktere donuseceginden artik numerik islemler yapamazsiniz. Vektorun belli bir elemanini almak icin [] operatoru kullanilir. x[2] ## [1] &quot;karakter&quot; 3.5.3 Liste Listeler, birden fazla obje turunu icerebilir: mylist = list(1, 2, TRUE, &#39;a&#39;) mylist ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] &quot;a&quot; Listenin belli bir elemanini almak icinse [[]] operatoru kullanilmalidir: mylist[[1]] ## [1] 1 mylist[[3]] ## [1] TRUE 3.5.4 Matris Matrisler iki boyutlu verilerdir, yanyana dizilmis ayni uzunluktaki vektorler gibi de dusunebilirsiniz: a &lt;- 1:2 b &lt;- 3:4 c &lt;- 5:6 x = cbind(a,b,c) x ## a b c ## [1,] 1 3 5 ## [2,] 2 4 6 y = rbind(a,b,c) y ## [,1] [,2] ## a 1 2 ## b 3 4 ## c 5 6 dim(x) ## [1] 2 3 x[1,1] ## a ## 1 x[1,2] ## b ## 3 x[1,] ## a b c ## 1 3 5 x[,2] ## [1] 3 4 colnames(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; rownames(x) ## NULL rownames(x) = c(&#39;satir1&#39;,&#39;satir2&#39;) x ## a b c ## satir1 1 3 5 ## satir2 2 4 6 dimnames(x) ## [[1]] ## [1] &quot;satir1&quot; &quot;satir2&quot; ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 3.5.5 Faktör Faktörler kategorik verilerle uğraşırken kullandığımız verilerdir. Yani değişkenimiz sadece belli bir set içinden değer alabilir. a = c(&quot;elma&quot;, &quot;muz&quot;, &quot;elma&quot;, &quot;armut&quot;, &quot;muz&quot;) a ## [1] &quot;elma&quot; &quot;muz&quot; &quot;elma&quot; &quot;armut&quot; &quot;muz&quot; class(a) ## [1] &quot;character&quot; a = factor(c(&quot;elma&quot;, &quot;muz&quot;, &quot;elma&quot;, &quot;armut&quot;, &quot;muz&quot;)) a ## [1] elma muz elma armut muz ## Levels: armut elma muz class(a) ## [1] &quot;factor&quot; levels(a) ## [1] &quot;armut&quot; &quot;elma&quot; &quot;muz&quot; 3.5.6 Data frame Data frame goruntu itibariyle matrisleri andirsa da farkli veri tiplerini barindirabilmesinden dolayi, liste gibidir. x = data.frame(id = c(1,2,3,4), isim = c(&#39;ali&#39;,&#39;veli&#39;,&#39;ayse&#39;,&#39;fatma&#39;), ogrenci = c(T,T,F,T)) x ## id isim ogrenci ## 1 1 ali TRUE ## 2 2 veli TRUE ## 3 3 ayse FALSE ## 4 4 fatma TRUE class(x) ## [1] &quot;data.frame&quot; data.frame icinde bir sutunu almak icin matrislerde oldugu gibi [] ya da $ operatorunu kullanabilirsiniz: x[,2] ## [1] &quot;ali&quot; &quot;veli&quot; &quot;ayse&quot; &quot;fatma&quot; x$isim ## [1] &quot;ali&quot; &quot;veli&quot; &quot;ayse&quot; &quot;fatma&quot; x[3,2] ## [1] &quot;ayse&quot; x$isim[3] ## [1] &quot;ayse&quot; 3.6 Paketler Son olarak R’da ozellesmis bazi fonksiyonlari ve veri tiplerini bulabileceginiz fonksiyonlar vardir. Bunlardan bazilari R’i indirdiginiz CRAN uzerinden, bazilari (ozellikle biyolojik veri analizi ile ilgili olanlari) Bioconductor uzerinden, bazilari da paketi olusturan kisilerin github repolari uzerinden indirilir. Indirme komutlari farkli olsa da, hepsi library(PAKETADI) komutu ile R’a yuklenir. Kullanisli bir kac paketi yukleyelim: CRAN’dan indirmek icin: install.packages(&#39;ggplot2&#39;) Bioconductor’dan paket indirmeden once, CRAN’dan BiocManager paketini indirmeniz gerekir: install.packages(&quot;BiocManager&quot;) Bioconductor’dan paket indirmek icin, BiocManager’i library() fonksiyonu ile Ra yuklemeden BiocManager:: ile bu paket icindeki bir fonksiyonu kullanabilirsiniz: BiocManager::install(&quot;preprocessCore&quot;) GitHub’dan bir paket indirmek icinse CRANdan indireceginiz devtools paketine ihtiyaciniz vardir. Paketlerin Github sayfalarindan indirme komutuna ulasabilirsiniz. Biz calistayda bu sekilde bir paket kullanmayacagiz. "],
["insan-prefrontal-korteksinde-gen-ifadesinin-zamansal-dinamikleri.html", "Bölüm 4 Insan prefrontal korteksinde gen ifadesinin zamansal dinamikleri 4.1 Calistay icin verinin on hazirligi", " Bölüm 4 Insan prefrontal korteksinde gen ifadesinin zamansal dinamikleri Bu calismada 2011 yilinda yayinlanmis bir makalede uretilmis olan bir microarray (mikrodizin?) veriseti kullanacagiz. Gorece eski bir teknolojiyle uretilmis olsa da verinin ve veri isleme basamaklari acik bir sekilde makalede paylasilmis durumda. Bu calistay mikrodizin / transkriptom veri analizi calistayi olmadigindan bu basamaklardan bazilarini atlayacagiz (orn. kismen islenmis veri ile baslayacak ve veride batch etkisi olmadigini varsayacagiz) ve kendi verinizi analiz edecek olursaniz bu calistayi birebir takip etmeniz yeterli olmayacaktir. Ancak makalede basamaklar anlatildigindan, kendiniz onlari tekrar edebilir daha detayli ogrenebilirsiniz. Kisaca, bu verisetinde cok sayida, farkli yaslarda bireylerin olum sonrasi beyin, prefontal korteks bolgesinden alinan orneklerde gen ifade verisi var. Biz de bu verisetini indirip, yasa bagli anlatimi degisen genler neler vs. gibi kimi sorulara cevap arayacagiz. Veriseti GEO’da herkese acik bir sekilde bulunuyor, ancak veriyi indirme asamasinda kullanilacak paket ve fonksiyonlar calistayin odagini degistirebileceginden o kismi atlayip, ilk indirme islemi tamamlandiktan sonraki kisma odaklanacagiz. Veriyi indirmek icin GEO baglantisi: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE30272 Makale: Colantuoni, C., Lipska, B. K., Ye, T., Hyde, T. M., Tao, R., Leek, J. T., Colantuoni, E. A., Elkahloun, A. G., Herman, M. M., Weinberger, D. R., &amp; Kleinman, J. E. (2011). Temporal dynamics and genetic control of transcription in the human prefrontal cortex. Nature, 478(7370), 519–523. https://doi.org/10.1038/nature10524 4.1 Calistay icin verinin on hazirligi Bu kismi calistay sirasinda yapmayacagim ve sizlere on hazirligi yapilmis bir veriseti sunacagim. Ancak kendiniz veriyi GEO’dan indirip ayni basamaklari tekrar etmek isterseniz, basamaklari burada paylasiyorum: Kismi islenmis veriyi GEOquery paketi ile GEOdan indirebiliriz: BiocManager::install(&quot;GEOquery&quot;) library(GEOquery) gse &lt;- getGEO(&#39;GSE30272&#39;,GSEMatrix=TRUE) Bu bize bir ExpressionSet objesi veriyor: gse Buradan bireylere ait metadata, gen ekspresyon matrisi, ve gen-probeset eslesmesini bulabilecegimiz bir feature verisi olusturalim: metadata = pData(gse$GSE30272_series_matrix.txt.gz) exprmat = exprs(gse$GSE30272_series_matrix.txt.gz) featdata = fData(gse$GSE30272_series_matrix.txt.gz) Bazi bilgileri kullanmayacagiz, bu yuzden verisetinin sadece belli sutunlarini aliyorum: metadata = metadata[,c(1,2,10:17)] featdata = featdata[,c(1,6,7,8)] .rds objesi olarak kaydetmek icin: saveRDS(exprmat, &#39;./data/expressionmatrix.rds&#39;) saveRDS(featdata, &#39;./data/featuredat.rds&#39;) saveRDS(metadata, &#39;./data/metadata.rds&#39;) .csv dosyasi olarak kaydetmek icin: write.csv(exprmat,&#39;./data/expressionmatrix.csv&#39;) write.csv(featdata,&#39;./data/featuredat.csv&#39;) write.csv(metadata,&#39;./data/metadata.csv&#39;) "],
["veri-on-isleme-basamaklari.html", "Bölüm 5 Veri on isleme basamaklari 5.1 read.csv() ve readRDS() ile veri okuma 5.2 Kesifci veri analizi 5.3 ProbesetID - Gen eslestirmesi 5.4 Quantile Normalization 5.5 Ornek bilgisini duzenleme", " Bölüm 5 Veri on isleme basamaklari Veriyi GEO’dan ifade matrisi, metadata yani bireylere dair bilginin bulundugu bir tablo, ve feature data yani probeset-gen eslesmelerinin verildigi bir tablo olarak kaydettim. Simdi bunlari okuyarak baslayacagiz. Ilk olarak gen ifade verisiyle baslayalim. 5.1 read.csv() ve readRDS() ile veri okuma read.csv fonksiyonu hem URL’den okuma hem de bilgisayarimizdaki bir dosyadan okuma yapmamizi saglar. Dosyayi github repomdan indirip, fonksiyona file = degiskeni olarak bilgisayarinizda indirdiginiz yeri vererek okuyabilirsiniz. Simdi kolaylik olmasi acisindan direkt olarak github repomdan okuyacagiz. Bu fonksiyon ayrica baska argumanlar da aliyor. header dosyada sutun isimlerinin yer alip almadigini belirtmek icin kullaniliyor ve mantiksal bir arguman yani TRUE ya da FALSE degerlerini alabilir. Kullanacagimiz bir diger arguman ise row.names =, bu da satir isimlerinin hangi sutunda yer aldigini belirtmemiz icin gerekli. Eger bu argumani kullanmazsak, matrisimizin satir isimleri de bir sutun olarak okunacaktir. expr = read.csv(file = &#39;https://github.com/mdonertas/20210322_REgitim/raw/master/data/expressionmatrix.csv&#39;, header = T, row.names = 1) Ilk 6 satir ve 4 sutuna bakalim: expr[1:6,1:4] ## GSM749899 GSM749900 GSM749901 GSM749902 ## HEEBO-002-CTRL2I1 -1.455124 -2.6244200 -1.904436 -1.5793507 ## HEEBO-002-CTRL2I10 1.044670 0.4490985 0.619243 0.1930628 ## HEEBO-002-CTRL2I11 1.164344 1.5833201 1.150024 1.5764080 ## HEEBO-002-CTRL2I14 1.597227 1.4105770 1.469449 2.6433802 ## HEEBO-002-CTRL2I15 -1.454337 -1.9784923 -1.485409 -1.5038039 ## HEEBO-002-CTRL2I16 1.396667 0.7461117 1.212514 0.6586667 Her sey yolunda gozukuyor ama bir de bu objenin daha onceden ogrendigimiz gibi classina bakalim: class(expr) ## [1] &quot;data.frame&quot; Genellikle read.csv fonksiyonu bir data.frame olusturur. Biz bu objede kimi matris operasyonlari yapmak istiyoruz ve verimiz de sadece numerik degerlerden olusuyor. O yuzden bunu matrise donusturebiliriz. Bunun icin as.matrix yani ‘matrix olarak’ fonksiyonunu kullanabiliriz. expr = as.matrix(expr) Tekrar ilk birkac satir sutun ve class kontrolumuzu yapalim: expr[1:6, 1:4] ## GSM749899 GSM749900 GSM749901 GSM749902 ## HEEBO-002-CTRL2I1 -1.455124 -2.6244200 -1.904436 -1.5793507 ## HEEBO-002-CTRL2I10 1.044670 0.4490985 0.619243 0.1930628 ## HEEBO-002-CTRL2I11 1.164344 1.5833201 1.150024 1.5764080 ## HEEBO-002-CTRL2I14 1.597227 1.4105770 1.469449 2.6433802 ## HEEBO-002-CTRL2I15 -1.454337 -1.9784923 -1.485409 -1.5038039 ## HEEBO-002-CTRL2I16 1.396667 0.7461117 1.212514 0.6586667 class(expr) ## [1] &quot;matrix&quot; &quot;array&quot; Arraylerden baslangicta bahsetmemistim, kullanimi cok asiri yaygin degil ama bunlar da 1 ya da daha fazla boyutlu vektorler olarak dusunulebilir, yani iki boyutlusu matris ama daha fazla boyutlu array olusturmak mumkun. Simdi bir de matrisimizin boyutlarina bakalim. Bunu ya satir (nrow()) ve sutun sayisini (ncol()) yazdirarak ya da dim() fonksiyonu ile yapabiliriz. nrow(expr) ## [1] 30176 ncol(expr) ## [1] 269 dim(expr) ## [1] 30176 269 Matrisimizde 30176 satir, 269 sutun var - yani 30176 probeset ID, 269 ornek. Daha fazla ilerlemeden once bir veri okuma sekli daha gostermek istiyorum. Alternatif olarak ayni veriyi bir .rds - R objesi olarak da kaydetmistim. Onu okumak icin de readRDS() fonksiyonunu kullanabiliriz. Bunun avantaji verinizin bir csv dosyasina kaydedilerek olasi bozulmalarini engellemenin yani sira, obje turunu vs. de koruyabilirsiniz. expr = readRDS(file = &#39;./data/expressionmatrix.rds&#39;) class(expr) ## [1] &quot;matrix&quot; &quot;array&quot; expr[1:6,1:4] ## GSM749899 GSM749900 GSM749901 GSM749902 ## HEEBO-002-CTRL2I1 -1.455124 -2.6244200 -1.904436 -1.5793507 ## HEEBO-002-CTRL2I10 1.044670 0.4490985 0.619243 0.1930628 ## HEEBO-002-CTRL2I11 1.164344 1.5833201 1.150024 1.5764080 ## HEEBO-002-CTRL2I14 1.597227 1.4105770 1.469449 2.6433802 ## HEEBO-002-CTRL2I15 -1.454337 -1.9784923 -1.485409 -1.5038039 ## HEEBO-002-CTRL2I16 1.396667 0.7461117 1.212514 0.6586667 dim(expr) ## [1] 30176 269 Gordugunuz gibi bu dosyayi okudugumuzda veriyi direkt olarak matrix olarak okuyabildik ve data.frame’den donusturmek zorunda kalmadik. 5.2 Kesifci veri analizi Daha ileri gecmeden hemen bu asamada cok kisaca verimiz neye benziyor bakabiliriz. Bunun icin temel bir kac gorsellestirme fonksiyonu kullanacagiz. 5.2.1 Histogram Ilk olarak verimizin dagilimi nedir, ne gibi degerler var bunlara bakalim. Bunun icin histogram kullanabiliriz, ve ilk olarak temel Rda histogram cizmeyi gorelim. hist(expr) Bu sekilde, hangi bireyin veya genin verisi olduguna bakmaksizin tum degerlerin bir histogramini aliriz. Bu histogram cogu gen ekpresyon verisinde alacaginiz ham veri grafiginden cok farkli, bunun sebebi bunun two channel microarray olmasi ve loess normalizasyonu gibi kimi normalizasyon asamalarindan da gecirilmis olmasi. Buna bakmak oldukca kolaydi, ama ben genel olarak ggplot2 paketinin gorsellestirmelerini kullaniyorum ve herkese en bastan itibaren ggplot ogrenmesini tavsiye ediyorum. Basit grafiklerde biraz zahmetli gelse de kompleks yayina hazir figur olusturmak icin cok ciddi kolaylik sagliyor. ggplot2 data.frame objesiyle calisir, oysa bu bir matris. Bu yuzden ufak bir degisiklik yapmamiz lazim: library(ggplot2) mydat = reshape2::melt(expr) ggplot(mydat, aes(x = value)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(mydat, aes(x = value)) + geom_histogram(color = &#39;gray60&#39;, bins = 50) + xlab(&#39;Probeset Expression&#39;) + ylab(&#39;Count&#39;) + theme_bw() 5.2.2 Boxplot Simdi de ilk birkac bireyin gen anlatim profillerine bakalim. Ilk once base R gorsellestirme fonksiyonu ile: boxplot(expr[,1:5]) Ayni grafigi ilk bir kac gen icin cizmek isteyecek olsak, hem matrisi subset etmemiz hem de transpoze etmemiz gerekir. Bunu t() fonksiyonu ile kolaylikla yapabiliriz: boxplot(t(expr[1:10,])) Aynisini ggplot ile yapalim: mydat = reshape2::melt(expr[,1:5]) head(mydat) ## Var1 Var2 value ## 1 HEEBO-002-CTRL2I1 GSM749899 -1.455124 ## 2 HEEBO-002-CTRL2I10 GSM749899 1.044670 ## 3 HEEBO-002-CTRL2I11 GSM749899 1.164344 ## 4 HEEBO-002-CTRL2I14 GSM749899 1.597227 ## 5 HEEBO-002-CTRL2I15 GSM749899 -1.454337 ## 6 HEEBO-002-CTRL2I16 GSM749899 1.396667 ggplot(mydat,aes(x = Var2, y = value)) + geom_boxplot(outlier.size = 0.01, outlier.color = &#39;gray&#39;, color = &#39;darkred&#39;) + theme_bw() + xlab(NULL) + ylab(&#39;Probeset Expression Value&#39;) mydat = reshape2::melt(expr[1:5,]) head(mydat) ## Var1 Var2 value ## 1 HEEBO-002-CTRL2I1 GSM749899 -1.455124 ## 2 HEEBO-002-CTRL2I10 GSM749899 1.044670 ## 3 HEEBO-002-CTRL2I11 GSM749899 1.164344 ## 4 HEEBO-002-CTRL2I14 GSM749899 1.597227 ## 5 HEEBO-002-CTRL2I15 GSM749899 -1.454337 ## 6 HEEBO-002-CTRL2I1 GSM749900 -2.624420 ggplot(mydat,aes(x = Var1, y = value)) + geom_boxplot(outlier.shape=NA, color = &#39;darkred&#39;) + geom_jitter(size = 0.5, width = 0.1) + theme_bw() + xlab(NULL) + ylab(&#39;Probeset Expression Value&#39;) 5.3 ProbesetID - Gen eslestirmesi Ayni gen ifade verisi gibi probesetID - gen eslesmesi bilgisinin kayitli oldugu bir tablo daha kaydetmistim. Simdi onu okuyalim: genedata = read.csv(&#39;https://github.com/mdonertas/20210322_REgitim/raw/master/data/featuredat.csv&#39;) genedata[1:3,] ## X ID OligoID ## 1 HEEBO-002-CTRL2I1 HEEBO-002-CTRL2I1 hCT000577 ## 2 HEEBO-002-CTRL2I10 HEEBO-002-CTRL2I10 hCT000586 ## 3 HEEBO-002-CTRL2I11 HEEBO-002-CTRL2I11 hCT000587 ## SEQUENCE ## 1 ACTCTGGATCCTGGGCGACGTCTTCATCGGCCGCTACTACACTGTGTTTGACCGTGACAACAACAGGGTG ## 2 CATCCTCACCGACATCACCAAGGGTGTGCAGTACCTCAACGAGATCAAGGACAGTGTGGTGGCCGGCTTC ## 3 GTCCCTGGAACGCCAGATGCGTGAAATGGAAGAGAACTTTGCCGTTGAAGCTGCTAACTACCAAGACACT ## GB_ACC Strand Gene_Symbol Gene_Title ## 1 NM_001909.4 + CTSD cathepsin D ## 2 NM_001961.3 + EEF2 eukaryotic translation elongation factor 2 ## 3 NM_003380.3 + VIM vimentin ## Entrez_Gene_ID UniGene_Cluster_ID Feb2012_Blast_Cutoffs SPOT_ID ## 1 1509 Hs.654447 100/100_Unique_RefSeq ## 2 1938 Hs.515070 100/100_Unique_RefSeq ## 3 7431 Hs.455493 100/100_Unique_RefSeq class(genedata) ## [1] &quot;data.frame&quot; Ilk olarak gen bilgisini duzenleyelim. Bunun icin bu data.frame’den iki sutunu kullanacagiz. genedata$ID[1:10] ## [1] &quot;HEEBO-002-CTRL2I1&quot; &quot;HEEBO-002-CTRL2I10&quot; &quot;HEEBO-002-CTRL2I11&quot; ## [4] &quot;HEEBO-002-CTRL2I14&quot; &quot;HEEBO-002-CTRL2I15&quot; &quot;HEEBO-002-CTRL2I16&quot; ## [7] &quot;HEEBO-002-CTRL2I17&quot; &quot;HEEBO-002-CTRL2I18&quot; &quot;HEEBO-002-CTRL2I19&quot; ## [10] &quot;HEEBO-002-CTRL2I2&quot; genedata$Gene_Symbol[1:10] ## [1] &quot;CTSD&quot; &quot;EEF2&quot; &quot;VIM&quot; &quot;VIM&quot; &quot;GSN&quot; &quot;EEF2&quot; &quot;VIM&quot; &quot;CTSD&quot; &quot;RPN2&quot; &quot;RPN2&quot; Simdi isimlendirilmis bir vektor olusturacagim ki, belli bir probe IDye karsilik gelen geni bulabileyim. Bunu yapmak icin setNames() fonksiyonunu kullanacagim. Isimler, yani ikinci arguman, probeID olacak, vektorun kendisi ise genler, bu sayede vektoru belli bir probe ID kullanarak subset ettigimde hangi gen oldugunu bulabilirim. Buna gecmeden bir ornek: x = setNames(c(1:3),c(&#39;bir&#39;,&#39;iki&#39;,&#39;uc&#39;)) x ## bir iki uc ## 1 2 3 ikinci elemani almak icin: x[2] ## iki ## 2 x[&#39;iki&#39;] ## iki ## 2 Bunlarin ikisini de kullanabiliyorum. IDleri kullanarak genleri bulmam da ayni sekilde olacak: genemap = setNames(genedata$Gene_Symbol,genedata$ID) genemap[1:5] ## HEEBO-002-CTRL2I1 HEEBO-002-CTRL2I10 HEEBO-002-CTRL2I11 HEEBO-002-CTRL2I14 ## &quot;CTSD&quot; &quot;EEF2&quot; &quot;VIM&quot; &quot;VIM&quot; ## HEEBO-002-CTRL2I15 ## &quot;GSN&quot; head(genemap) ## HEEBO-002-CTRL2I1 HEEBO-002-CTRL2I10 HEEBO-002-CTRL2I11 HEEBO-002-CTRL2I14 ## &quot;CTSD&quot; &quot;EEF2&quot; &quot;VIM&quot; &quot;VIM&quot; ## HEEBO-002-CTRL2I15 HEEBO-002-CTRL2I16 ## &quot;GSN&quot; &quot;EEF2&quot; Matrisin satir isimleriyle genemap’i subset ettigimiz zaman, dogru sirayla hangi genlere karsilik geliyorsa bize bu bilgiyi verecek. Simdi once bir yanlis yapma ihtimalimize karsin matrisimizi kopyalayalim: expr_yedek = expr Simdi ilk olarak bir probeset ID birden fazla genle eslesiyor mu buna bakmaliyiz, bunlar veri duplikasyonu yaratacagindan istatistiksel test yapmamizi zorlastirir bunlari veriden cikararak baslayacagiz: any(duplicated(names(genemap))) ## [1] FALSE Hic tekrar eden bir probesetIDmiz yok - yani bu bu veriseti icin problem degil. Bir de cok fazla sayida probesetIDye map olmus olan genlere bakalim: sort(table(genemap),dec=T)[1:10] ## genemap ## ##noname## LRP1 OCRL TLN1 TTN CDH23 ## 903 825 88 62 55 55 41 ## ANXA7 RB1 DNAH9 ## 40 40 37 Bunlardan '##noname## ve '' tabii ki gen ismi degil. Bunlari veriden cikartmak gerekir, ama bunu matrixe isimleri gecirdikten sonra yapacagim. Simdi probeset IDleri gen isimleriyle degistirerek devam edelim: rownames(expr) = genemap[rownames(expr)] expr[1:5,1:5] ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 ## CTSD -1.455124 -2.6244200 -1.904436 -1.5793507 -2.1666262 ## EEF2 1.044670 0.4490985 0.619243 0.1930628 -0.4370544 ## VIM 1.164344 1.5833201 1.150024 1.5764080 1.3569308 ## VIM 1.597227 1.4105770 1.469449 2.6433802 1.7567335 ## GSN -1.454337 -1.9784923 -1.485409 -1.5038039 -1.2828650 sort(table(rownames(expr)), dec = T)[1:10] ## ## ##noname## LRP1 OCRL TLN1 TTN CDH23 ## 903 825 88 62 55 55 41 ## ANXA7 RB1 DNAH9 ## 40 40 37 Burada gordugunuz gibi bazi gen isimleri birden fazla kez tekrar ediliyor. Bu mikrodizin dizaynindan kaynakli bir durum, her gen bir ya da daha fazla probeset ile temsil ediliyor. Genelde her gen bu probesetlerin ortalamasi ya da maksimumu alinarak ozetlenir - bu sayede her gen matriste bir defa yer alir. Bunu yapmak icin matrisi gen isimleriyle subset etmeyi ogrenecegiz. Zaten belli bir isimle subset yapmayi biliyoruz, ancak bu sadece tekrarli olmayan durumlarda gecerli. Suna bakalim: x = setNames(c(1:5), c(&#39;bir&#39;,&#39;iki&#39;,&#39;iki&#39;,&#39;dort&#39;,&#39;bes&#39;)) x[&#39;iki&#39;] ## iki ## 2 oysa 3 degerine sahip olan elemanin adi da ‘iki.’ Bu tarz tekrarli durumlarda otomatik olarak ilk eleman verilir. Ikisini birden istiyorsak subset islemini %in% operatoru ile yapmamiz gerekir. 5.3.1 %in% operatoru &#39;elma&#39; %in% c(&#39;elma&#39;,&#39;armut&#39;) ## [1] TRUE &#39;muz&#39; %in% c(&#39;elma&#39;,&#39;armut&#39;) ## [1] FALSE c(&#39;elma&#39;, &#39;muz&#39;) %in% &#39;elma&#39; ## [1] TRUE FALSE c(&#39;elma&#39;, &#39;muz&#39;) %in% &#39;muz&#39; ## [1] FALSE TRUE Bilmemiz gereken bir konu da bir vektoru ya da matrisi mantiksal degiskenlerle de subset edebildigimiz: c(1:5)[c(T,T,F,T,F)] ## [1] 1 2 4 Ilk olarak gen ismi olarak '##noname## ve '' gorunen satirlari veriden cikartarak baslamaliyiz: expr = expr[!rownames(expr) %in% c(&#39;##noname##&#39;,&#39;&#39;),] sort(table(rownames(expr)),dec=T)[1:10] ## ## LRP1 OCRL TLN1 TTN CDH23 ANXA7 RB1 DNAH9 WDFY3 SYNE2 ## 88 62 55 55 41 40 40 37 37 36 Simdi tekrar eden genleri ozetlemeye geri donelim. expr[rownames(expr) %in% &#39;VIM&#39;, 1:5] ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 ## VIM 1.164344 1.583320 1.150024 1.576408 1.356931 ## VIM 1.597227 1.410577 1.469449 2.643380 1.756734 ## VIM 2.475041 2.236114 2.179526 2.807048 2.443889 ## VIM 2.414010 2.242931 2.379348 1.909755 2.596801 ## VIM 2.913906 1.343048 2.536056 2.271887 2.118884 ## VIM 1.743049 1.492585 1.621053 1.394594 2.030154 ## VIM 1.171174 1.165681 1.099818 2.274270 1.541334 ## VIM 1.446696 1.451936 1.782307 2.605349 1.957581 ## VIM 1.131674 1.172329 1.053107 1.871871 1.780982 Simdi yeni bir fonksiyon ogrenelim colMeans() bu da adi ustunde sutun ortalamasini aliyor. Yani matrisi tum VIM genine karsilik gelen probesetler icin subset edip, colMeans() dersek tek boyutlu, satirlarin ortalamasina sahip bir vektor verecek: vimmeans = colMeans(expr[rownames(expr) %in% &#39;VIM&#39;, ]) head(vimmeans) ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 GSM749904 ## 1.784125 1.566502 1.696743 2.150507 1.953699 1.409357 Ama bu sadece tek bir gen icin. Oysa biz tek genle ilgilenmiyoruz, butun genler icin bunu yapmak istiyoruz. Eger programlama dillerine asinaysaniz for loop larini duymussunuzdur. Bunlar ayni islemin defalarca ayni ya da farkli inputlar icin tekrarlanmasini saglar. R’da da for loop yazabiliriz bunun icin kullanilacak fonksiyon for. Bizse for yerine R’a ozgu *apply fonksiyonlari olarak gecen fonksiyonlardan biri olan sapply() fonksiyonu ile bunu yapacagiz. Ilk olarak butun gen isimlerini almaliyiz. Bunu sadece rownames() ile alamiyoruz cunku isimler tekrar ediyor. Onun yerine her degerin sadece bir kere tekrar edilmesini unique() fonksiyonu ile saglayacagiz. genisimleri = unique(rownames(expr)) nrow(expr) ## [1] 28448 length(genisimleri) ## [1] 17160 Sadece 17bin gen var. Yani her gen cok defa tekrar ediliyor olmak zorunda degil. Eger tekrar edilmeyen bir geni subset edersek, ‘sutun ortalamalarini ver’ demek icin kullanacagimiz colMeans fonksiyonu calismaz, cunku bir matris degil bir vektor soz konusu olacak. Bunun icin bir de if fonksiyonunu ogrenmeliyiz. if bir kodu ancak belli kosullar altinda calistiracaktir. Bu sayede eger bir defa geciyorsa sunu yap, birden fazla kez tekrar ediliyorsa sunu yap seklinde bir kod yazmamiz mumkun olacak. If’e cok kisa bir ornek: vektorum = c(&#39;elma&#39;,&#39;muz&#39;,&#39;armut&#39;) if(&#39;cilek&#39;%in%vektorum){ print(&#39;cilek var!&#39;) } else if(&#39;elma&#39; %in% vektorum){ print(&#39;elma var!&#39;) } else{ print(&#39;ne cilek ne elma var :(&#39;) } ## [1] &quot;elma var!&quot; daha iyi anlayabilmemiz icin bir ornek daha: vektorum = c(&#39;elma&#39;,&#39;muz&#39;,&#39;armut&#39;) if(&#39;muz&#39;%in%vektorum){ print(&#39;muz var!&#39;) } else if(&#39;elma&#39; %in% vektorum){ print(&#39;elma var!&#39;) } else{ print(&#39;ne cilek ne elma var :(&#39;) } ## [1] &quot;muz var!&quot; hem elma hem muz olmasina ragmen sadece birinci komut calisti. Bunun sebebi else komutu ancak ilk kodumuz yanlissa calisacak olmasi. Simdi de cok kisa sapply() nasil calisiyor buna bakalim: sapply(c(1:10),function(i){ i * 2 }) ## [1] 2 4 6 8 10 12 14 16 18 20 sapply(c(1:10),function(i){ i * (i-1) }) ## [1] 0 2 6 12 20 30 42 56 72 90 Simdi biraz ileri duzey gibi gorunmesi muhtemel bir kod yazacagiz ama basamak basamak inceleyince anlasilmasi kolay olacaktir: genexpr = sapply(genisimleri, function(gen) { i = rownames(expr)%in%gen if(sum(i)&gt;1){ colMeans(expr[i,]) } else if(sum(i)==1){ expr[i,] } }) genexpr[1:5,1:5] ## CTSD EEF2 VIM GSN RPN2 ## GSM749899 -0.8124619 1.5620237 1.784125 -0.6578933 1.658038 ## GSM749900 -1.3310489 1.4339156 1.566502 -1.1007844 1.528385 ## GSM749901 -1.2447029 0.9832866 1.696743 -1.0306526 1.286318 ## GSM749902 -1.2017866 0.7393814 2.150507 -0.8413292 1.153392 ## GSM749903 -1.1041998 0.2957918 1.953699 -0.7242716 0.789019 satir-sutun yer degistirmis durumda. bunu yine transpoze ederek duzeltebiliriz: genexpr = t(genexpr) genexpr[1:5,1:5] ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 ## CTSD -0.8124619 -1.331049 -1.2447029 -1.2017866 -1.1041998 ## EEF2 1.5620237 1.433916 0.9832866 0.7393814 0.2957918 ## VIM 1.7841245 1.566502 1.6967431 2.1505070 1.9536987 ## GSN -0.6578933 -1.100784 -1.0306526 -0.8413292 -0.7242716 ## RPN2 1.6580375 1.528385 1.2863177 1.1533917 0.7890190 dim(genexpr) ## [1] 17160 269 Artik her gen icin bir satirimiz var! 5.4 Quantile Normalization Son olarak bu gen ifade matrixinde bir normalizasyon metodu uygulayalim. Burada amacimiz farkli ornekler arasindaki olasi teknik varyasyonu ortadan kaldirmak. Uygulayacagimiz normalizasyonun adi ‘quantile normalization’ - bunun sonunda tum orneklerin dagilimlari ayni olacak - genler farkli degerler alacak ama genlerin dagilimi ayni olacak. Normalizasyon oncesi ilk bir kac bireyin dagilimina bakalim. boxplot(genexpr[,1:20]) Gordugunuz gibi ortalamalari hemen hemen ayni olsa da (bunun sebebi verinin zaten baska bir yontemle kismen normalize edilmis olmasi), Dagilimlar farkli. Normalizasyon icin Rda olmayan bir fonksiyon kullanacagiz, bunun icin de preprocessCore paketini yuklememiz gerekiyor: BiocManager::install(&quot;preprocessCore&quot;) library(preprocessCore) Fonksiyonumuzun adi normalize.quantiles() genexpr_qn = normalize.quantiles(genexpr) dim(genexpr_qn) ## [1] 17160 269 genexpr_qn[1:5,1:5] ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.4993920 -0.6776740 -0.7796459 -0.8040486 -0.8587960 ## [2,] 1.0141904 0.8355595 0.6704056 0.5563232 0.2924776 ## [3,] 1.1413791 0.9140343 1.1026208 1.4685350 1.5103426 ## [4,] -0.4112961 -0.5602207 -0.6620208 -0.5704519 -0.6015157 ## [5,] 1.0659865 0.8908564 0.8555507 0.8361596 0.6749602 Gordugunuz gibi bu fonksiyon ne yazik ki satir sutun isimlerimizi sildi. Ama bunlarin ilk matrisimizle ayni oldugunu biliyoruz cunku bir subset islemi yapmadik. Eski satir-sutun isimlerimizi yeni matrisimize aktaralim: dimnames(genexpr_qn) = dimnames(genexpr) genexpr_qn[1:5,1:5] ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 ## CTSD -0.4993920 -0.6776740 -0.7796459 -0.8040486 -0.8587960 ## EEF2 1.0141904 0.8355595 0.6704056 0.5563232 0.2924776 ## VIM 1.1413791 0.9140343 1.1026208 1.4685350 1.5103426 ## GSN -0.4112961 -0.5602207 -0.6620208 -0.5704519 -0.6015157 ## RPN2 1.0659865 0.8908564 0.8555507 0.8361596 0.6749602 Tekrar dagilimlara bakacak olursak: boxplot(genexpr_qn[,1:20]) Gordugunuz gibi dagilimlar birebir esit oldu. Bundan sonraki asamalarda bu veriyi kullanacagiz. 5.5 Ornek bilgisini duzenleme Son olarak, bir de orneklerle ilgili bilgilerin yer aldigi (yas, biyolojik cinsiyet) bir tablomuz var. Ama bu verinin de duzenlenmesi gerekiyor. metadata = read.csv(&#39;https://github.com/mdonertas/20210322_REgitim/raw/master/data/metadata.csv&#39;) head(metadata) ## X title geo_accession characteristics_ch1 characteristics_ch1.1 ## 1 GSM749899 HB_18_34 GSM749899 array batch: 10 age: -0.498630137 ## 2 GSM749900 HB_22_35 GSM749900 array batch: 18 age: -0.498630137 ## 3 GSM749901 HB_16_29 GSM749901 array batch: 1 age: -0.498630137 ## 4 GSM749902 HB_17_91 GSM749902 array batch: 8 age: -0.498630137 ## 5 GSM749903 HB_18_16 GSM749903 array batch: 9 age: -0.479452055 ## 6 GSM749904 HB_16_62 GSM749904 array batch: 3 age: -0.479452055 ## characteristics_ch1.2 characteristics_ch1.3 characteristics_ch1.4 ## 1 Sex: F race: AA postmortem interval (pmi): 3 ## 2 Sex: F race: AA postmortem interval (pmi): 1 ## 3 Sex: M race: AA postmortem interval (pmi): 1 ## 4 Sex: M race: AA postmortem interval (pmi): 4 ## 5 Sex: M race: AA postmortem interval (pmi): 2 ## 6 Sex: M race: AA postmortem interval (pmi): 4 ## characteristics_ch1.5 characteristics_ch1.6 characteristics_ch1.7 ## 1 ph: NULL rna integrity number (rin): 9.7 smoke at death: No ## 2 ph: 6.21 rna integrity number (rin): 9.8 smoke at death: No ## 3 ph: NULL rna integrity number (rin): 9.6 smoke at death: No ## 4 ph: NULL rna integrity number (rin): 9.8 smoke at death: No ## 5 ph: NULL rna integrity number (rin): 9 smoke at death: Unknown ## 6 ph: NULL rna integrity number (rin): 9.8 smoke at death: No Bu veriyi kullanarak, ayni probeset-gen eslestirmesi icin yaptigimiz gibi yas ve biyolojik cinsiyet icin birey bilgisi vektoru olusturalim: yas = setNames(metadata$characteristics_ch1.1, metadata$geo_accession) head(yas) ## GSM749899 GSM749900 GSM749901 GSM749902 ## &quot;age: -0.498630137&quot; &quot;age: -0.498630137&quot; &quot;age: -0.498630137&quot; &quot;age: -0.498630137&quot; ## GSM749903 GSM749904 ## &quot;age: -0.479452055&quot; &quot;age: -0.479452055&quot; class(yas) ## [1] &quot;character&quot; cinsiyet = setNames(metadata$characteristics_ch1.2, metadata$geo_accession) head(cinsiyet) ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 GSM749904 ## &quot;Sex: F&quot; &quot;Sex: F&quot; &quot;Sex: M&quot; &quot;Sex: M&quot; &quot;Sex: M&quot; &quot;Sex: M&quot; class(cinsiyet) ## [1] &quot;character&quot; Bu veriler gordugunuz gibi karakter verileri ve formatlari pek iyi degil. Ornegin bu yas verisiyle yapabileceklerimiz sinirli cunku numerik degil. Ilk olarak basta yazan ‘age:’ kismindan kurtulmamiz lazim ki bu yas verisini kullanabilelim. Ayni sekilde biyolojik cinsiyeti de ‘F’ veya ‘M’ haline, hatta daha iyisi ‘kadin’ ve ‘erkek’ haline getirelim. 5.5.1 Yas verisinin duzenlenmesi Basta yazan ‘age:’ yazisinin ortadan kaldirilmasi icin bir kac secenek var. Bunlardan en basiti gsub fonksiyonu. Bu fonksiyon, bir karakter vektorunde belli karakterlerin degistirilmesini saglar: gsub(&#39;range&#39;,&#39;&#39;,&#39;Bioinforange&#39;) ## [1] &quot;Bioinfo&quot; gsub(&#39;range&#39;,&#39;conference&#39;,&#39;Bioinforange&#39;) ## [1] &quot;Bioinfoconference&quot; Bu sekilde ‘age:’ yazisini silebiliriz: yas = gsub(&#39;age: &#39;,&#39;&#39;,yas) head(yas) ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 ## &quot;-0.498630137&quot; &quot;-0.498630137&quot; &quot;-0.498630137&quot; &quot;-0.498630137&quot; &quot;-0.479452055&quot; ## GSM749904 ## &quot;-0.479452055&quot; Ancak gordugunuz gibi, veri hala karakter. Bunu numerik yapmak icin as.numeric() kullaniriz: yas = setNames(as.numeric(yas),names(yas)) hist(yas) Daha net bir sekilde verinin ozetini gormek istersek summary() fonksiyonunu kullanabiliriz: summary(yas) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -0.4986 5.3452 24.2658 27.7920 46.9671 78.2274 Dogum oncesi zamandan 78 yasina kadar bireyler var ve ortalamamiz 27.7. 5.5.2 Biyolojik cinsiyet verisinin duzenlenmesi Bu sefer sadece 2 biyolojik cinsiyet mumkun oldugundan daha farkli bir yol izleyebiliriz. Ama oncelikle, sadece iki secenek oldugundan emin olalim. unique(cinsiyet) ## [1] &quot;Sex: F&quot; &quot;Sex: M&quot; &quot;Sex: 5&quot; Bir de ‘5’ var, bu muhtemelen veri girisinde bir hata demek ama bu bireyi en azindan cinsiyet icin inceleyemeyecegimiz anlamina geliyor. Ilk olarak bu veriye sahip olan bireyi hem bu veriden hem expression verisinden hem de yas verisinden cikaralim. cikart = names(cinsiyet[(cinsiyet %in% &#39;Sex: 5&#39;)]) cinsiyet = cinsiyet[!names(cinsiyet) %in% cikart] yas = yas[!names(yas) %in% cikart] genexpr_qn = genexpr_qn[,!colnames(genexpr_qn) %in% cikart] Ayni probeset-gen eslesmesi yapmak icin kullandigimiz gibi bir vektor olusturalim: cinsiyetMap = setNames(c(&#39;Kadin&#39;,&#39;Erkek&#39;),c(&#39;Sex: F&#39;,&#39;Sex: M&#39;)) cinsiyet = setNames(cinsiyetMap[cinsiyet],names(cinsiyet)) head(cinsiyet) ## GSM749899 GSM749900 GSM749901 GSM749902 GSM749903 GSM749904 ## &quot;Kadin&quot; &quot;Kadin&quot; &quot;Erkek&quot; &quot;Erkek&quot; &quot;Erkek&quot; &quot;Erkek&quot; Kac kadin kac erkek bireyin olduguna bakmak icin table() fonksiyonunu kullanabiliriz: table(cinsiyet) ## cinsiyet ## Erkek Kadin ## 177 91 "],
["temel-bilesenler-analizi.html", "Bölüm 6 Temel bilesenler analizi", " Bölüm 6 Temel bilesenler analizi tba = prcomp(t(genexpr_qn), scale. = T) renkler = colorRampPalette(c(&#39;pink&#39;,&#39;darkred&#39;))(length(yas)) renkler_sirali = renkler[rank(yas[rownames(tba$x)], ties.method = &#39;min&#39;)] plot(x = tba$x[,1], y = tba$x[,2], pch = 19, cex = 0.5, col = renkler_sirali, xlab = &#39;PC1&#39;, ylab = &#39;PC2&#39;) Ayni figuru ggplot ile yapabiliriz. Ancak bunun icin bir kac tidyversede yer alan paketlerden bir kac fonksiyon kullanarak veriyi sekillendirmem gerekiyor: library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ tibble 3.0.6 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.1 ## ✓ purrr 0.3.4 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() pcadat = as.data.frame(tba$x[,1:2]) %&gt;% mutate(sample = rownames(tba$x)) %&gt;% mutate(yas = yas[sample], cinsiyet = cinsiyet[sample]) head(pcadat) ## PC1 PC2 sample yas cinsiyet ## 1 -138.7854 -0.7978871 GSM749899 -0.4986301 Kadin ## 2 -137.1751 15.9124596 GSM749900 -0.4986301 Kadin ## 3 -142.7689 13.8844269 GSM749901 -0.4986301 Erkek ## 4 -137.0419 9.0980053 GSM749902 -0.4986301 Erkek ## 5 -133.6389 0.6007799 GSM749903 -0.4794521 Erkek ## 6 -131.6583 16.4774424 GSM749904 -0.4794521 Erkek ggplot(pcadat, aes(x = PC1, y = PC2, color = yas, shape = cinsiyet)) + geom_point(size = 3) + scale_color_gradient(low = &#39;pink&#39;, high = &#39;darkred&#39;) + theme_bw() "],
["yasla-degisim-analizi.html", "Bölüm 7 Yasla degisim analizi", " Bölüm 7 Yasla degisim analizi Diyelim ki sadece dogum sonrasi donemde 20 sonrasi yasta yasla degisen genlerle ilgileniyoruz. Bunun icin ilk olarak veriyi subset etmeliyiz. Yas’in 20den buyuk oldugu bireyleri almaliyiz: subsamp = names(which(yas&gt;=20)) subexp = genexpr_qn[,subsamp] subyas = yas[subsamp] yasladegisim = apply(subexp, 1, function(x){ co = cor.test(x, subyas[colnames(subexp)], method = &#39;spearman&#39;) c(co$est, co$p.val) }) dim(yasladegisim) ## [1] 2 17160 yasladegisim = t(yasladegisim) head(yasladegisim) ## rho ## CTSD -0.03253336 0.6956624723 ## EEF2 -0.12309924 0.1374343793 ## VIM 0.28300932 0.0005395356 ## GSN 0.11697104 0.1581010511 ## RPN2 -0.22977129 0.0052073498 ## POLR2A 0.01173037 0.8878589579 colnames(yasladegisim) = c(&#39;rho&#39;,&#39;p&#39;) yasladegisim = cbind(yasladegisim, p.adjust(yasladegisim[,&#39;p&#39;], method= &#39;fdr&#39;)) Hangi genler yasla istatistiksel olarak anlamli degisim gosteriyor? anlamli = names(which(yasladegisim[,3]&lt;=0.05)) table(yasladegisim[rownames(yasladegisim)%in%anlamli,1]&gt;=0) ## ## FALSE TRUE ## 1538 1418 Bunlardan 1419 tanesi artis yonunde anlamli degisim gosteriyor, 1538 tanesi ise dusus. Bunlardan en cok artis gostereni secip gorsellestirelim: maxartis = names(which.max(yasladegisim[,1])) yasladegisim[maxartis,] ## rho p ## 6.980232e-01 8.761466e-23 1.002312e-19 plot(x = subyas, y = subexp[maxartis,], pch = 19, cex = 0.5, xlab=&#39;Yas&#39;, ylab = &#39;Gen ifadesi&#39;, main = maxartis) abline(lm(subexp[maxartis,]~subyas), col = &#39;darkred&#39;,cex = 2) pdf(&#39;./yasladegisim.pdf&#39;) plot(x = subyas, y = subexp[maxartis,], pch = 19, cex = 0.5, xlab=&#39;Yas&#39;, ylab = &#39;Gen ifadesi&#39;, main = maxartis) abline(lm(subexp[maxartis,]~subyas), col = &#39;darkred&#39;,cex = 2) dev.off() ## quartz_off_screen ## 2 write.csv(x = yasladegisim, file = &#39;./yasladegisim.csv&#39;,quote = F, row.names = T) Ayni figuru ggplot ile cizelim: mydat = data.frame(expression = subexp[maxartis,], sample = colnames(subexp), yas = subyas[colnames(subexp)],cinsiyet = cinsiyet[colnames(subexp)]) ggplot(mydat, aes(x = yas, y = expression)) + geom_point(aes(color = cinsiyet)) + geom_smooth(method = &#39;lm&#39;, color = &#39;midnightblue&#39;) + scale_color_brewer(type = &#39;qual&#39;, palette = 6) + theme_bw() ## `geom_smooth()` using formula &#39;y ~ x&#39; "],
["biyolojik-cinsiyete-gore-farklilik-gosteren-gen-analizi.html", "Bölüm 8 Biyolojik cinsiyete gore farklilik gosteren gen analizi", " Bölüm 8 Biyolojik cinsiyete gore farklilik gosteren gen analizi Diyelim ki sadece dogum sonrasi donemde 20 sonrasi ve 40 yas oncesi yasta kadin ve erkekler arasinda farkli gen ifadesi gosteren genlerle ilgileniyoruz. subsamp = names(which(yas&gt;=20 &amp; yas&lt;40)) subexp = genexpr_qn[,subsamp] subyas = yas[subsamp] subcins = cinsiyet[subsamp] table(subcins) ## subcins ## Erkek Kadin ## 41 12 Kadin ve erkek sayisindaki fark cok fazla. Hem erkek hem de kadinlarin icinden rastegele 10ar birey secip analiz yapalim (- rastgele secim yapmayi gostermek icin!). erkek = sample(names(which(subcins == &#39;Erkek&#39;)),10,replace = F) kadin = sample(names(which(subcins == &#39;Kadin&#39;)),10,replace = F) subsamp = c(erkek,kadin) subexp = genexpr_qn[,subsamp] subyas = yas[subsamp] subcins = cinsiyet[subsamp] table(subcins) ## subcins ## Erkek Kadin ## 10 10 cinsiyetfark = apply(subexp, 1, function(x){ tres = t.test(x~subcins) c(tres$statistic, tres$p.value) }) dim(cinsiyetfark) ## [1] 2 17160 cinsiyetfark = t(cinsiyetfark) head(cinsiyetfark) ## t ## CTSD 1.2022368 0.2475190 ## EEF2 0.7313033 0.4743186 ## VIM 0.1130708 0.9113746 ## GSN -0.1262172 0.9010494 ## RPN2 0.6787791 0.5072433 ## POLR2A 0.1274177 0.9001053 colnames(cinsiyetfark) = c(&#39;t&#39;,&#39;p&#39;) cinsiyetfark = cbind(cinsiyetfark,p.adjust(cinsiyetfark[,&#39;p&#39;],method= &#39;fdr&#39;)) Hangi genler yasla istatistiksel olarak anlamli degisim gosteriyor? anlamli = names(which(cinsiyetfark[,3]&lt;=0.05)) length(anlamli) ## [1] 13 Sadece 12 gen anlamli fark gostermis. maxfark = names(which.max(abs(cinsiyetfark[,1]))) cinsiyetfark[maxfark,] ## t p ## 4.814198e+01 2.327394e-20 3.993809e-16 boxplot(subexp[maxfark,]~subcins, ylab = &#39;Gen ifadesi&#39;, main = maxfark, xlab = &#39;Cinsiyet&#39;) Figuru kaydetmek icin: pdf(&#39;./cinsiyetfark.pdf&#39;) boxplot(subexp[maxfark,]~subcins, ylab = &#39;Gen ifadesi&#39;, main = maxfark, xlab = &#39;Cinsiyet&#39;) dev.off() ## quartz_off_screen ## 2 Ayni figuru ggplotta cizelim: mydat = data.frame(expression = subexp[maxfark,], cinsiyet = subcins[colnames(subexp)], yas = yas[colnames(subexp)]) ggplot(mydat, aes(x = cinsiyet, y = expression)) + geom_violin(aes(fill = cinsiyet), alpha = 0.5) + scale_fill_brewer(type=&#39;qual&#39;, palette = 6)+ geom_boxplot(outlier.shape = NA, width = 0.1) + theme_bw() "],
["kaynak-onerileri.html", "Bölüm 9 Kaynak onerileri 9.1 Online ders 9.2 Kitaplar 9.3 Diger", " Bölüm 9 Kaynak onerileri 9.1 Online ders R ve veri bilimine giris: https://www.edx.org/professional-certificate/harvardx-data-science R ve yasam bilimlerinde veri analizi: https://www.edx.org/professional-certificate/harvardx-data-analysis-for-life-sciences Rda genomik analiz: https://www.edx.org/professional-certificate/harvardx-data-analysis-for-genomics R programlama: https://www.coursera.org/learn/r-programming Coursera Data Science Specialization icinde ~10 ders var: https://www.coursera.org/specializations/jhu-data-science 9.2 Kitaplar R Programming for Data Science: https://leanpub.com/rprogramming Data Analysis for the Life Sciences: https://leanpub.com/dataanalysisforthelifesciences Tidyverse ogrenmek icin: https://r4ds.had.co.nz/ ggplot’ta grafikler: https://ggplot2-book.org/ 9.3 Diger Zaman zaman R’da hem giris duzeyinde Turkce ders notlari hem de biyolojide kullanilan grafiklere ornekler paylastigim bir blogum var: https://compbioscratchpad.com/bilgi-deposu/ Kaynak onerileriniz olursa bana iletirseniz bu sayfayi guncelleyebilirim. "]
]
